# 3.3 - Encoding Channels

```elixir
Mix.install([
  {:explorer, "~> 0.2.0"},
  {:kino, "~> 0.6.2"},
  {:kino_vega_lite, "~> 0.1.3"}
])
```

## Intro

You are going to learn about how to encode data to the following channels channels

* Color
* Size
* Opacity
* Shape
* Conditional Encoding
* Multiple Conditions

Packages you will need:

* VegaLite
* Kino
* Kino_VegaLite
* Explorer

<!-- livebook:{"break_markdown":true} -->

What are channels?  
The visual properties of a chart (like size, opacity and color) you **encode** with your data.  Said another way, channels are where you can customize your chart with your data to

Vega-Lite provides you numerous channels to use for chart creation.  You can see all of them listed here:

https://vega.github.io/vega-lite/docs/encoding.html

If you remember back to the VegaLite template, the typical code structure for a chart is ...

<!-- livebook:{"force_markdown":true} -->

```elixir
Vl.new() # Initialize a Vega-Lite Chart
|> Vl.data_from_*(data) # Read in data
|> Vl.transform() # Manipulate the data - optional
|> Vl.param() # Add interactivity - optional
|> Vl.mark(:mark) # Specify the shape used
|> Vl.encode_field(:var, "field_name", type: :quantitative) # Encode channels (:x, :y, etc...) with specific fields from the dataset
... # encode as many channels as you wish
```

In this section, you'll be focused on the hightlighted line of code:

<!-- livebook:{"force_markdown":true} -->

```elixir
#Vl.new() # Initialize a Vega-Lite Chart
#|> Vl.data_from_*(data) # Read in data
#|> Vl.transform() # Manipulate the data - optional
#|> Vl.param() # Add interactivity - optional
#|> Vl.mark(:mark) # Specify the shape used
|> Vl.encode_field(:var, "field_name", type: :quantitative)
# ...
```

## Setup

```elixir
alias Explorer.{DataFrame, Series}
alias VegaLite, as: Vl

house_file = "~/Documents/elixir4ds/data/mpg.csv"

house = DataFrame.from_csv!(house_file)
```

## Color

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
```

How can we create a scatterplot where x is displ, y is hwy and class is color using Smart Cells?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode_field(:color, "BldgType", type: :nominal)
```

## Size

How can we redo the scatterplot from above with no color where class is represented by size?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode_field(:size, "OverallCond", type: :nominal)
```

## Opacity

How can we re-create the scatterplot from above where the class is alpha in one chart and shape in another side-by-side?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode_field(:opacity, "OverallCond", type: :nominal)
```

## Shape

How can we re-create the scatterplot above where the `shape` is the `OverallCond`?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode_field(:shape, "OverallCond", type: :nominal)
```

## Individual Colors

How can we turn all the points in the chart blue?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode(:color, value: "red")
```

What is the difference between `encode` and `encode_field`?

## Conditional Encoding

How Can We Highlight just the `2seater` class?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode_field(:size, "OverallCond", type: :nominal)
|> Vl.encode(:color,
  condition: %{test: "datum['OverallCond'] >= 7", value: "blue"},
  value: "grey"
)
```

## Multiple Conditions

How Can We Highlight the `2seater` class where the `displ` is greater than 6.0?

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(house)
# |> Vl.param()
|> Vl.transform(filter: "datum['BldgType'] != '1Fam'")
|> Vl.mark(:point)
|> Vl.encode_field(:x, "GrLivArea", type: :quantitative)
|> Vl.encode_field(:y, "SalePrice", type: :quantitative)
|> Vl.encode_field(:size, "OverallCond", type: :nominal)
|> Vl.encode(:color,
  condition: %{test: "datum['OverallCond'] >= 7 & datum['GrLivArea'] > 1000", value: "red"},
  value: "black"
)
```

## Project

How Kino Automatically change the chart color based on an external input?

Kino - https://hexdocs.pm/kino/Kino.Input.html

```elixir
input = Kino.Input.number("displ")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(mpg)
|> Vl.mark(:circle)
|> Vl.encode_field(:x, "displ", type: :quantitative)
|> Vl.encode_field(:y, "hwy", type: :quantitative)
|> Vl.encode(:color,
  condition: %{test: "datum['displ'] > #{Kino.Input.read(input)}", value: "red"},
  value: "black"
)
```

Leave exercises for people to do on their own...post any questions they may have or problems they run into in the comments section below.

```elixir
fields = mpg.names
```

```elixir
options = Enum.zip(fields, fields)
```

```elixir
field = Kino.Input.select("Fields", options)
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Vl.new(width: 400)
|> Vl.data_from_values(mpg)
|> Vl.mark(:circle)
|> Vl.encode_field(:x, "displ", type: :quantitative)
|> Vl.encode_field(:y, "#{Kino.Input.read(field)}", type: :nominal)
```
